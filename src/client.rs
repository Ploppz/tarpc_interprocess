use interprocess::nonblocking::local_socket::*;
use tarpc_interprocess::*;
use std::net::IpAddr;

use tarpc::{context, rpc::client::Config, serde_transport::Transport};
use tokio_util::compat::FuturesAsyncReadCompatExt;

use tokio_serde::formats::Bincode;

#[tokio::main]
async fn main() -> std::io::Result<()> {

    let server_addr = (IpAddr::from([0, 0, 0, 0]), 5555);
    let mut transport = tarpc::serde_transport::tcp::connect(server_addr, Bincode::default);
    transport.config_mut().max_frame_length(4294967296);

    // WorldClient is generated by the service attribute. It has a constructor `new` that takes a
    // config and any Transport as input.
    let mut client = WorldClient::new(Config::default(), transport.await?)
        .spawn()
        .unwrap();

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    let hello = client
        .hello(context::current(), "Client".to_string())
        .await
        .unwrap();

    println!("Reply: {}", hello);

    Ok(())
}
